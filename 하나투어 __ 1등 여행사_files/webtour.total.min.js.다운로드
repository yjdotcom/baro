!function (e, t) { "function" == typeof define && define.amd ? define([], function () { t(e) }) : t(e) }("undefined" != typeof exports ? exports : this, function (e) { if (e.atob) try { e.atob(" ") } catch (o) { e.atob = (t = e.atob, (r = function (e) { return t(String(e).replace(/[\t\n\f\r ]+/g, "")) }).original = t, r) } else { var t, r, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", n = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/; e.btoa = function (e) { for (var t, r, n, i, a = "", c = 0, l = (e = String(e)).length % 3; c < e.length;) { if ((r = e.charCodeAt(c++)) > 255 || (n = e.charCodeAt(c++)) > 255 || (i = e.charCodeAt(c++)) > 255) throw new TypeError("Failed to execute 'btoa' on 'Window': The string to be encoded contains characters outside of the Latin1 range."); a += o.charAt((t = r << 16 | n << 8 | i) >> 18 & 63) + o.charAt(t >> 12 & 63) + o.charAt(t >> 6 & 63) + o.charAt(63 & t) } return l ? a.slice(0, l - 3) + "===".substring(l) : a }, e.atob = function (e) { if (e = String(e).replace(/[\t\n\f\r ]+/g, ""), !n.test(e)) throw new TypeError("Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded."); e += "==".slice(2 - (3 & e.length)); for (var t, r, i, a = "", c = 0; c < e.length;)t = o.indexOf(e.charAt(c++)) << 18 | o.indexOf(e.charAt(c++)) << 12 | (r = o.indexOf(e.charAt(c++))) << 6 | (i = o.indexOf(e.charAt(c++))), a += 64 === r ? String.fromCharCode(t >> 16 & 255) : 64 === i ? String.fromCharCode(t >> 16 & 255, t >> 8 & 255) : String.fromCharCode(t >> 16 & 255, t >> 8 & 255, 255 & t); return a } } }); var effect = !1, ua = window.navigator.userAgent, msie = ua.indexOf("MSIE "), rv11 = ua.indexOf("rv:11.0"); if (msie > 0) { var vs = ua.slice(msie + 5), version = parseInt(vs); version && version <= 11 && (effect = !0) } rv11 > -1 && (effect = !0), effect && function (e) { function t(e) { if (1 / e == -1 / 0 && (e = 0), e > Math.pow(2, 32) - 1) throw new RangeError("Invalid array length"); var t = []; return t.length = e, t } function r(e, t) { var r = arguments.length > 2 ? arguments[2] : []; if (!1 === c(e)) throw new TypeError(Object.prototype.toString.call(e) + "is not a function."); return e.apply(t, r) } function o(e, t, r) { var o = { value: r, writable: !0, enumerable: !0, configurable: !0 }; try { return Object.defineProperty(e, t, o), !0 } catch (e) { return !1 } } function n(e, t, r) { var n = o(e, t, r); if (!n) throw new TypeError("Cannot assign value `" + Object.prototype.toString.call(r) + "` to property `" + Object.prototype.toString.call(t) + "` on object `" + Object.prototype.toString.call(e) + "`"); return n } function i(e, t, r) { var o = { value: r, writable: !0, enumerable: !1, configurable: !0 }; Object.defineProperty(e, t, o) } function a(e, t) { return e[t] } function c(e) { return "function" == typeof e } function l(e) { var t = function (e) { var t = Number(e); return isNaN(t) ? 0 : 1 / t == 1 / 0 || 1 / t == -1 / 0 || t === 1 / 0 || t === -1 / 0 ? t : (t < 0 ? -1 : 1) * Math.floor(Math.abs(t)) }(e); return t <= 0 ? 0 : Math.min(t, Math.pow(2, 53) - 1) } function u(t) { if (null === t || t === e) throw TypeError(); return Object(t) } function p(e, t) { return u(e)[t] } function s(t, r) { var o = p(t, r); if (null === o || o === e) return e; if (!1 === c(o)) throw new TypeError("Method not callable: " + r); return o } function f(e) { switch (typeof e) { case "undefined": return "undefined"; case "boolean": return "boolean"; case "number": return "number"; case "string": return "string"; case "symbol": return "symbol"; default: return null === e ? "null" : "Symbol" in this && e instanceof this.Symbol ? "symbol" : "object" } } function h(e, t) { if ("boolean" !== f(t)) throw new Error; var r = {}; return o(r, "value", e), o(r, "done", t), r } function y(e, t) { var r = arguments[2] || {}, o = function (e, t) { var r = a(e, "prototype"); return "object" !== f(r) && (r = t), r }(e, t), n = Object.create(o); for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && Object.defineProperty(n, i, { configurable: !0, enumerable: !1, writable: !0, value: r[i] }); return n } function b(e) { return "object" === f(e) && "function" == typeof e && !!e.prototype } function v(e) { var t = arguments.length > 2 ? arguments[2] : e, o = arguments.length > 1 ? arguments[1] : []; if (!b(e)) throw new TypeError("F must be a constructor."); if (!b(t)) throw new TypeError("newTarget must be a constructor."); return t === e ? new (Function.prototype.bind.apply(e, [null].concat(o))) : r(e, y(t, Object.prototype), o) } function d(t, o) { if ("object" !== f(t["[[Iterator]]"])) throw new Error(Object.prototype.toString.call(t["[[Iterator]]"]) + "is not an Object."); var n = t["[[Iterator]]"], i = s(n, "return"); if (i === e) return o; try { var a = r(i, n) } catch (e) { var c = e } if (o) return o; if (c) throw c; if ("object" !== f(a)) throw new TypeError("Iterator's return method returned a non-object."); return o } function w(e) { if ("object" !== f(e)) throw new Error(Object.prototype.toString.call(e) + "is not an Object."); return t = a(e, "done"), Boolean(t); var t } function g(e) { var t = function (e) { if (arguments.length < 2) var t = r(e["[[NextMethod]]"], e["[[Iterator]]"]); else t = r(e["[[NextMethod]]"], e["[[Iterator]]"], [arguments[1]]); if ("object" !== f(t)) throw new TypeError("bad iterator"); return t }(e); return !0 !== w(t) && t } function m(e) { if ("object" !== f(e)) throw new Error(Object.prototype.toString.call(e) + "is not an Object."); return a(e, "value") } function j(e, t) { return f(e) === f(t) && ("number" === f(e) ? !(!isNaN(e) || !isNaN(t)) || 1 / e == 1 / 0 && 1 / t == -1 / 0 || 1 / e == -1 / 0 && 1 / t == 1 / 0 || e === t : function (e, t) { return e === t }(e, t)) } function S(t) { var o = arguments.length > 1 ? arguments[1] : e; if ("object" === f(t)) { if (arguments.length < 2) var n = "default"; else o === String ? n = "string" : o === Number && (n = "number"); var i = "function" == typeof this.Symbol && "symbol" == typeof this.Symbol.toPrimitive ? s(t, this.Symbol.toPrimitive) : e; if (i !== e) { var l = r(i, t, [n]); if ("object" !== f(l)) return l; throw new TypeError("Cannot convert exotic object to primitive.") } return "default" === n && (n = "number"), function (e, t) { if ("string" === t) var o = ["toString", "valueOf"]; else o = ["valueOf", "toString"]; for (var n = 0; n < o.length; ++n) { var i = a(e, o[n]); if (c(i)) { var l = r(i, e); if ("object" !== f(l)) return l } } throw new TypeError("Cannot convert to primitive.") }(t, n) } return t } function O(e) { switch (f(e)) { case "symbol": throw new TypeError("Cannot convert a Symbol value to a string"); case "object": return O(S(e, "string")); default: return String(e) } } var M, E; function _(e) { var t = r(arguments.length > 1 ? arguments[1] : s(e, Symbol.iterator), e); if ("object" !== f(t)) throw new TypeError("bad iterator"); var o = p(t, "next"), n = Object.create(null); return n["[[Iterator]]"] = t, n["[[NextMethod]]"] = o, n["[[Done]]"] = !1, n } M = {}.toString, E = "".split, i(Object, "entries", function (e) { return u(e), function (e, t) { for (var r = Object.keys(e), o = [], n = r.length, i = 0; i < n; i++) { var c = r[i]; if ("string" === f(c)) { var l = Object.getOwnPropertyDescriptor(e, c); if (l && l.enumerable) if ("key" === t) o.push(c); else { var u = a(e, c); if ("value" === t) o.push(u); else { var p = [c, u]; o.push(p) } } } } return o }("[object String]" == M.call(e) ? E.call(e, "") : Object(e), "key+value") }), function (e, t, r) { "use strict"; var o, n = 0, i = "" + Math.random(), a = "__symbol:", c = a.length, l = "__symbol@@" + i, u = "defineProperty", p = "defineProperties", s = "getOwnPropertyNames", f = "getOwnPropertyDescriptor", h = "propertyIsEnumerable", y = e.prototype, b = y.hasOwnProperty, v = y[h], d = y.toString, w = Array.prototype.concat, g = e.getOwnPropertyNames ? e.getOwnPropertyNames(window) : [], m = e[s], j = function (e) { if ("[object Window]" === d.call(e)) try { return m(e) } catch (e) { return w.call([], g) } return m(e) }, S = e[f], O = e.create, M = e.keys, E = e.freeze || e, _ = e[u], T = e[p], P = S(e, s), k = function (e, t, r) { if (!b.call(e, l)) try { _(e, l, { enumerable: !1, configurable: !1, writable: !1, value: {} }) } catch (t) { e[l] = {} } e[l]["@@" + t] = r }, I = function () { }, x = function (e) { return e != l && !b.call(D, e) }, z = function (e) { return e != l && b.call(D, e) }, N = function (e) { var t = "" + e; return z(t) ? b.call(this, t) && this[l]["@@" + t] : v.call(this, e) }, A = function (t) { var r = { enumerable: !1, configurable: !0, get: I, set: function (e) { o(this, t, { enumerable: !1, configurable: !0, writable: !0, value: e }), k(this, t, !0) } }; try { _(y, t, r) } catch (e) { y[t] = r.value } return E(D[t] = _(e(t), "constructor", F)) }, C = function e() { var t = arguments[0]; if (this instanceof e) throw new TypeError("Symbol is not a constructor"); return A(a.concat(t || "", i, ++n)) }, D = O(null), F = { value: C }, K = function (e) { return D[e] }, L = function (e, t, r) { var n = "" + t; return z(n) ? (o(e, n, r.enumerable ? function (e) { var t = O(e); return t.enumerable = !1, t }(r) : r), k(e, n, !!r.enumerable)) : _(e, t, r), e }, V = function (e) { return j(e).filter(e === y ? function (e) { return function (t) { return b.call(e, l) && b.call(e[l], "@@" + t) } }(e) : z).map(K) }; P.value = L, _(e, u, P), P.value = V, _(e, "getOwnPropertySymbols", P), P.value = function (e) { return j(e).filter(x) }, _(e, s, P), P.value = function (e, t) { var r = V(t); return r.length ? M(t).concat(r).forEach(function (r) { N.call(t, r) && L(e, r, t[r]) }) : T(e, t), e }, _(e, p, P), P.value = N, _(y, h, P), P.value = C, _(r, "Symbol", P), P.value = function (e) { var t = a.concat(a, e, i); return t in y ? D[t] : A(t) }, _(C, "for", P), P.value = function (e) { if (x(e)) throw new TypeError(e + " is not a symbol"); return b.call(D, e) ? e.slice(2 * c, -i.length) : void 0 }, _(C, "keyFor", P), P.value = function (e, t) { var r = S(e, t); return r && z(t) && (r.enumerable = N.call(e, t)), r }, _(e, f, P), P.value = function (e, t) { return 1 === arguments.length || void 0 === t ? O(e) : function (e, t) { var r = O(e); return j(t).forEach(function (e) { N.call(t, e) && L(r, e, t[e]) }), r }(e, t) }, _(e, "create", P); var $ = null === function () { return this }.call(null); P.value = $ ? function () { var e = d.call(this); return "[object String]" === e && z(this) ? "[object Symbol]" : e } : function () { if (this === window) return "[object Null]"; var e = d.call(this); return "[object String]" === e && z(this) ? "[object Symbol]" : e }, _(y, "toString", P), o = function (e, t, r) { var o = S(y, t); delete y[t], _(e, t, r), e !== y && _(y, t, o) } }(Object, 0, this), Object.defineProperty(Symbol, "iterator", { value: Symbol("iterator") }), Object.defineProperty(Symbol, "species", { value: Symbol("species") }), function (t) { function r(e, t) { if ("object" !== f(e)) throw new TypeError("createMapIterator called on incompatible receiver " + Object.prototype.toString.call(e)); if (!0 !== e._es6Map) throw new TypeError("createMapIterator called on incompatible receiver " + Object.prototype.toString.call(e)); var r = Object.create(l); return Object.defineProperty(r, "[[Map]]", { configurable: !0, enumerable: !1, writable: !0, value: e }), Object.defineProperty(r, "[[MapNextIndex]]", { configurable: !0, enumerable: !1, writable: !0, value: 0 }), Object.defineProperty(r, "[[MapIterationKind]]", { configurable: !0, enumerable: !1, writable: !0, value: t }), r } var o = function () { try { var t = {}; return Object.defineProperty(t, "t", { configurable: !0, enumerable: !1, get: function () { return !0 }, set: e }), !!t.t } catch (e) { return !1 } }(), n = Symbol("undef"), a = function t() { if (!(this instanceof t)) throw new TypeError('Constructor Map requires "new"'); var r = y(this, t.prototype, { _keys: [], _values: [], _size: 0, _es6Map: !0 }); o || Object.defineProperty(r, "size", { configurable: !0, enumerable: !1, writable: !0, value: 0 }); var n = arguments.length > 0 ? arguments[0] : e; if (null === n || n === e) return r; var i = r.set; if (!c(i)) throw new TypeError("Map.prototype.set is not a function"); try { for (var a = _(n); ;) { var l = g(a); if (!1 === l) return r; var u = m(l); if ("object" !== f(u)) try { throw new TypeError("Iterator value " + u + " is not an entry object") } catch (e) { return d(a, e) } try { var p = u[0], s = u[1]; i.call(r, p, s) } catch (e) { return d(a, e) } } } catch (e) { if (Array.isArray(n) || "[object Arguments]" === Object.prototype.toString.call(n) || n.callee) { var h, b = n.length; for (h = 0; h < b; h++)i.call(r, n[h][0], n[h][1]) } } return r }; Object.defineProperty(a, "prototype", { configurable: !1, enumerable: !1, writable: !1, value: {} }), o ? Object.defineProperty(a, Symbol.species, { configurable: !0, enumerable: !1, get: function () { return this }, set: e }) : i(a, Symbol.species, a), i(a.prototype, "clear", function () { var t = this; if ("object" !== f(t)) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._keys, i = 0; i < r.length; i++)t._keys[i] = n, t._values[i] = n; return this._size = 0, o || (this.size = this._size), e }), i(a.prototype, "constructor", a), i(a.prototype, "delete", function (e) { var t = this; if ("object" !== f(t)) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._keys, i = 0; i < r.length; i++)if (t._keys[i] !== n && j(t._keys[i], e)) return this._keys[i] = n, this._values[i] = n, this._size = --this._size, o || (this.size = this._size), !0; return !1 }), i(a.prototype, "entries", function () { return r(this, "key+value") }), i(a.prototype, "forEach", function (t) { var r = this; if ("object" !== f(r)) throw new TypeError("Method Map.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(r)); if (!0 !== r._es6Map) throw new TypeError("Method Map.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(r)); if (!c(t)) throw new TypeError(Object.prototype.toString.call(t) + " is not a function."); if (arguments[1]) var o = arguments[1]; for (var i = r._keys, a = 0; a < i.length; a++)r._keys[a] !== n && r._values[a] !== n && t.call(o, r._values[a], r._keys[a], r); return e }), i(a.prototype, "get", function (t) { var r = this; if ("object" !== f(r)) throw new TypeError("Method Map.prototype.get called on incompatible receiver " + Object.prototype.toString.call(r)); if (!0 !== r._es6Map) throw new TypeError("Method Map.prototype.get called on incompatible receiver " + Object.prototype.toString.call(r)); for (var o = r._keys, i = 0; i < o.length; i++)if (r._keys[i] !== n && j(r._keys[i], t)) return r._values[i]; return e }), i(a.prototype, "has", function (e) { var t = this; if ("object" != typeof t) throw new TypeError("Method Map.prototype.has called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.has called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._keys, o = 0; o < r.length; o++)if (t._keys[o] !== n && j(t._keys[o], e)) return !0; return !1 }), i(a.prototype, "keys", function () { return r(this, "key") }), i(a.prototype, "set", function (e, t) { var r = this; if ("object" !== f(r)) throw new TypeError("Method Map.prototype.set called on incompatible receiver " + Object.prototype.toString.call(r)); if (!0 !== r._es6Map) throw new TypeError("Method Map.prototype.set called on incompatible receiver " + Object.prototype.toString.call(r)); for (var i = r._keys, a = 0; a < i.length; a++)if (r._keys[a] !== n && j(r._keys[a], e)) return r._values[a] = t, r; -0 === e && (e = 0); var c = {}; return c["[[Key]]"] = e, c["[[Value]]"] = t, r._keys.push(c["[[Key]]"]), r._values.push(c["[[Value]]"]), ++r._size, o || (r.size = r._size), r }), o && Object.defineProperty(a.prototype, "size", { configurable: !0, enumerable: !1, get: function () { var e = this; if ("object" !== f(e)) throw new TypeError("Method Map.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e)); if (!0 !== e._es6Map) throw new TypeError("Method Map.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e)); for (var t = e._keys, r = 0, o = 0; o < t.length; o++)e._keys[o] !== n && (r += 1); return r }, set: e }), i(a.prototype, "values", function () { return r(this, "value") }), i(a.prototype, Symbol.iterator, a.prototype.entries), "name" in a || Object.defineProperty(a, "name", { configurable: !0, enumerable: !1, writable: !1, value: "Map" }); var l = {}; Object.defineProperty(l, "isMapIterator", { configurable: !1, enumerable: !1, writable: !1, value: !0 }), i(l, "next", function () { var t = this; if ("object" !== f(t)) throw new TypeError("Method %MapIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(t)); if (!t.isMapIterator) throw new TypeError("Method %MapIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(t)); var r = t["[[Map]]"], o = t["[[MapNextIndex]]"], i = t["[[MapIterationKind]]"]; if (r === e) return h(e, !0); if (!r._es6Map) throw new Error(Object.prototype.toString.call(r) + " has a [[MapData]] internal slot."); for (var a = r._keys.length; o < a;) { var c = Object.create(null); if (c["[[Key]]"] = r._keys[o], c["[[Value]]"] = r._values[o], o += 1, t["[[MapNextIndex]]"] = o, c["[[Key]]"] !== n) { if ("key" === i) var l = c["[[Key]]"]; else if ("value" === i) l = c["[[Value]]"]; else { if ("key+value" !== i) throw new Error; l = [c["[[Key]]"], c["[[Value]]"]] } return h(l, !1) } } return t["[[Map]]"] = e, h(e, !0) }), i(l, Symbol.iterator, function () { return this }); try { i(t, "Map", a) } catch (e) { t.Map = a } }(this), function (t) { function r(e, t) { if ("object" != typeof e) throw new TypeError("createSetIterator called on incompatible receiver " + Object.prototype.toString.call(e)); if (!0 !== e._es6Set) throw new TypeError("createSetIterator called on incompatible receiver " + Object.prototype.toString.call(e)); var r = Object.create(u); return Object.defineProperty(r, "[[IteratedSet]]", { configurable: !0, enumerable: !1, writable: !0, value: e }), Object.defineProperty(r, "[[SetNextIndex]]", { configurable: !0, enumerable: !1, writable: !0, value: 0 }), Object.defineProperty(r, "[[SetIterationKind]]", { configurable: !0, enumerable: !1, writable: !0, value: t }), r } var o = function () { try { var t = {}; return Object.defineProperty(t, "t", { configurable: !0, enumerable: !1, get: function () { return !0 }, set: e }), !!t.t } catch (e) { return !1 } }(), n = Symbol("undef"), a = function t() { if (!(this instanceof t)) throw new TypeError('Constructor Set requires "new"'); var r = y(this, t.prototype, { _values: [], _size: 0, _es6Set: !0 }); o || Object.defineProperty(r, "size", { configurable: !0, enumerable: !1, writable: !0, value: 0 }); var n = arguments.length > 0 ? arguments[0] : e; if (null === n || n === e) return r; var i = r.add; if (!c(i)) throw new TypeError("Set.prototype.add is not a function"); try { for (var a = _(n); ;) { var l = g(a); if (!1 === l) return r; var u = m(l); try { i.call(r, u) } catch (e) { return d(a, e) } } } catch (e) { if (!Array.isArray(n) && "[object Arguments]" !== Object.prototype.toString.call(n) && !n.callee) throw e; var p, s = n.length; for (p = 0; p < s; p++)i.call(r, n[p]) } return r }; Object.defineProperty(a, "prototype", { configurable: !1, enumerable: !1, writable: !1, value: {} }), o ? Object.defineProperty(a, Symbol.species, { configurable: !0, enumerable: !1, get: function () { return this }, set: e }) : i(a, Symbol.species, a), i(a.prototype, "add", function (e) { var t = this; if ("object" != typeof t) throw new TypeError("Method Set.prototype.add called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.add called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._values, i = 0; i < r.length; i++) { var a = r[i]; if (a !== n && j(a, e)) return t } return 1 / e == -1 / 0 && (e = 0), t._values.push(e), this._size = ++this._size, o || (this.size = this._size), t }), i(a.prototype, "clear", function () { var t = this; if ("object" != typeof t) throw new TypeError("Method Set.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._values, i = 0; i < r.length; i++)r[i] = n; return this._size = 0, o || (this.size = this._size), e }), i(a.prototype, "constructor", a), i(a.prototype, "delete", function (e) { var t = this; if ("object" != typeof t) throw new TypeError("Method Set.prototype.delete called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.delete called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._values, i = 0; i < r.length; i++) { var a = r[i]; if (a !== n && j(a, e)) return r[i] = n, this._size = --this._size, o || (this.size = this._size), !0 } return !1 }), i(a.prototype, "entries", function () { return r(this, "key+value") }), i(a.prototype, "forEach", function (t) { var r = this; if ("object" != typeof r) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(r)); if (!0 !== r._es6Set) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(r)); if (!c(t)) throw new TypeError(Object.prototype.toString.call(t) + " is not a function."); if (arguments[1]) var o = arguments[1]; for (var i = r._values, a = 0; a < i.length; a++) { var l = i[a]; l !== n && t.call(o, l, l, r) } return e }), i(a.prototype, "has", function (e) { var t = this; if ("object" != typeof t) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t)); if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t)); for (var r = t._values, o = 0; o < r.length; o++) { var i = r[o]; if (i !== n && j(i, e)) return !0 } return !1 }); var l = function () { return r(this, "value") }; i(a.prototype, "values", l), i(a.prototype, "keys", l), o && Object.defineProperty(a.prototype, "size", { configurable: !0, enumerable: !1, get: function () { var e = this; if ("object" != typeof e) throw new TypeError("Method Set.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e)); if (!0 !== e._es6Set) throw new TypeError("Method Set.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e)); for (var t = e._values, r = 0, o = 0; o < t.length; o++)t[o] !== n && (r += 1); return r }, set: e }), i(a.prototype, Symbol.iterator, l), "name" in a || Object.defineProperty(a, "name", { configurable: !0, enumerable: !1, writable: !1, value: "Set" }); var u = {}; Object.defineProperty(u, "isSetIterator", { configurable: !1, enumerable: !1, writable: !1, value: !0 }), i(u, "next", function () { var t = this; if ("object" != typeof t) throw new TypeError("Method %SetIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(t)); if (!t.isSetIterator) throw new TypeError("Method %SetIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(t)); var r = t["[[IteratedSet]]"], o = t["[[SetNextIndex]]"], i = t["[[SetIterationKind]]"]; if (r === e) return h(e, !0); if (!r._es6Set) throw new Error(Object.prototype.toString.call(r) + " does not have [[SetData]] internal slot."); for (var a = r._values, c = a.length; o < c;) { var l = a[o]; if (o += 1, t["[[SetNextIndex]]"] = o, l !== n) return h("key+value" === i ? [l, l] : l, !1) } return t["[[IteratedSet]]"] = e, h(e, !0) }), i(u, Symbol.iterator, function () { return this }); try { i(t, "Set", a) } catch (e) { t.Set = a } }(this), function () { function o(e) { return "string" == typeof e || "object" == typeof e && "[object String]" === p.call(e) } var p = Object.prototype.toString, f = String.prototype.match; i(Array, "from", function (i) { var p = this, h = arguments.length > 1 ? arguments[1] : e; if (h === e) var y = !1; else { if (!1 === c(h)) throw new TypeError(Object.prototype.toString.call(h) + " is not a function."); var w = arguments.length > 2 ? arguments[2] : e; if (w !== e) var j = w; else j = e; y = !0 } var S = s(i, Symbol.iterator); if (S !== e) { if (b(p)) var M = v(p); else M = t(0); for (var E = _(i, S), T = 0; ;) { if (T >= Math.pow(2, 53) - 1) return d(E, new TypeError("Iteration count can not be greater than or equal 9007199254740991.")); var P = O(T), k = g(E); if (!1 === k) return M.length = T, M; var I = m(k); if (y) try { var x = r(h, j, [I, T]) } catch (e) { return d(E, e) } else x = I; try { n(M, P, x) } catch (e) { return d(E, e) } T += 1 } } if (o(i)) var z = f.call(i, /[\uD800-\uDBFF][\uDC00-\uDFFF]?|[^\uD800-\uDFFF]|./g) || []; else z = u(i); var N = l(a(z, "length")); for (M = b(p) ? v(p, [N]) : t(N), T = 0; T < N;) { var A = a(z, P = O(T)); n(M, P, x = !0 === y ? r(h, j, [A, T]) : A), T += 1 } return M.length = N, M }) }() }.call("object" == typeof window && window || "object" == typeof self && self || "object" == typeof global && global || {}), function () { var e = function (e) { return e.replace(/^\s+|\s+$/g, "") }, t = function (e) { return new RegExp("(^|\\s+)" + e + "(\\s+|$)") }, r = function (e, t, r) { for (var o = 0; o < e.length; o++)t.call(r, e[o]) }; function o(e) { this.element = e } o.prototype = { add: function () { r(arguments, function (t) { this.contains(t) || (this.element.className = e(this.element.className + " " + t)) }, this) }, remove: function () { r(arguments, function (r) { this.element.className = e(this.element.className.replace(t(r), " ")) }, this) }, toggle: function (e) { return this.contains(e) ? (this.remove(e), !1) : (this.add(e), !0) }, contains: function (e) { return t(e).test(this.element.className) }, item: function (e) { return this.element.className.split(/\s+/)[e] || null }, replace: function (e, t) { this.remove(e), this.add(t) } }, "classList" in Element.prototype || Object.defineProperty(Element.prototype, "classList", { get: function () { return new o(this) } }), window.DOMTokenList && !DOMTokenList.prototype.replace && (DOMTokenList.prototype.replace = o.prototype.replace) }(), function (e) { function t(t) { this.input = t, "password" == t.attr("type") && this.handlePassword(), e(t[0].form).submit(function () { t.hasClass("placeholder") && t[0].value == t.attr("placeholder") && (t[0].value = "") }) } t.prototype = { show: function (e) { if ("" === this.input[0].value || e && this.valueIsPlaceholder()) { if (this.isPassword) try { this.input[0].setAttribute("type", "text") } catch (e) { this.input.before(this.fakePassword.show()).hide() } this.input.addClass("placeholder"), this.input[0].value = this.input.attr("placeholder") } }, hide: function () { if (this.valueIsPlaceholder() && this.input.hasClass("placeholder") && (this.input.removeClass("placeholder"), this.input[0].value = "", this.isPassword)) { try { this.input[0].setAttribute("type", "password") } catch (e) { } this.input.show(), this.input[0].focus() } }, valueIsPlaceholder: function () { return this.input[0].value == this.input.attr("placeholder") }, handlePassword: function () { var t = this.input; if (t.attr("realType", "password"), this.isPassword = !0, e.browser.msie && t[0].outerHTML) { var r = e(t[0].outerHTML.replace(/type=(['"])?password\1/gi, "type=$1text$1")); this.fakePassword = r.val(t.attr("placeholder")).addClass("placeholder").focus(function () { t.trigger("focus"), e(this).hide() }), e(t[0].form).submit(function () { r.remove(), t.show() }) } } }; var r = !!("placeholder" in document.createElement("input")); e.fn.placeholder = function () { return r ? this : this.each(function () { var r = e(this), o = new t(r); o.show(!0), r.focus(function () { o.hide() }), r.blur(function () { o.show(!1) }), e.browser.msie && (e(window).load(function () { r.val() && r.removeClass("placeholder"), o.show(!0) }), r.focus(function () { if ("" == this.value) { var e = this.createTextRange(); e.collapse(!0), e.moveStart("character", 0), e.select() } })) }) } }(jQuery);