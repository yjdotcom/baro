
//https://polyfill.io/v3/polyfill.min.js?features=Array.from%2CObject.entries%2CString.prototype.includes%2CArray.prototype.includes%2CString.prototype.endsWith

/* Disable minification (remove `.min` from URL path) for more info */

var effect = false;

var ua = window.navigator.userAgent;
var msie = ua.indexOf('MSIE ');
var rv11 = ua.indexOf('rv:11.0'); // ie11
// console.log(msie)

if( msie > 0  ){
  var vs = ua.slice(msie + 5);
  var version = parseInt(vs);

  if( version && version <= 11 ){
    effect = true;
  }
} else {
  // console.log(msie, ua)
}

if( rv11 > -1 ){
  effect = true;
}

if( effect ) {
  // console.log('this polyfill is affecting now.')
  (function (undefined) {
    function ArrayCreate(r) {
      if (1 / r == -Infinity && (r = 0), r > Math.pow(2, 32) - 1) throw new RangeError("Invalid array length");
      var n = [];
      return n.length = r, n
    }

    function Call(t, l) {
      var n = arguments.length > 2 ? arguments[2] : [];
      if (!1 === IsCallable(t)) throw new TypeError(Object.prototype.toString.call(t) + "is not a function.");
      return t.apply(l, n)
    }

    function CreateDataProperty(e, r, t) {
      var a = {value: t, writable: !0, enumerable: !0, configurable: !0};
      try {
        return Object.defineProperty(e, r, a), !0
      } catch (n) {
        return !1
      }
    }

    function CreateDataPropertyOrThrow(t, r, o) {
      var e = CreateDataProperty(t, r, o);
      if (!e) throw new TypeError("Cannot assign value `" + Object.prototype.toString.call(o) + "` to property `" + Object.prototype.toString.call(r) + "` on object `" + Object.prototype.toString.call(t) + "`");
      return e
    }

    function CreateMethodProperty(e, r, t) {
      var a = {value: t, writable: !0, enumerable: !1, configurable: !0};
      Object.defineProperty(e, r, a)
    }

    function Get(n, t) {
      return n[t]
    }

    function HasProperty(n, r) {
      return r in n
    }

    function IsArray(r) {
      return "[object Array]" === Object.prototype.toString.call(r)
    }

    function IsCallable(n) {
      return "function" == typeof n
    }

    function SameValueNonNumber(e, n) {
      return e === n
    }

    function ToBoolean(o) {
      return Boolean(o)
    }

    function ToInteger(n) {
      var i = Number(n);
      return isNaN(i) ? 0 : 1 / i === Infinity || 1 / i == -Infinity || i === Infinity || i === -Infinity ? i : (i < 0 ? -1 : 1) * Math.floor(Math.abs(i))
    }

    function ToLength(n) {
      var t = ToInteger(n);
      return t <= 0 ? 0 : Math.min(t, Math.pow(2, 53) - 1)
    }

    function ToObject(e) {
      if (null === e || e === undefined) throw TypeError();
      return Object(e)
    }

    function GetV(t, e) {
      return ToObject(t)[e]
    }

    function GetMethod(e, n) {
      var r = GetV(e, n);
      if (null === r || r === undefined) return undefined;
      if (!1 === IsCallable(r)) throw new TypeError("Method not callable: " + n);
      return r
    }

    function Type(e) {
      switch (typeof e) {
        case"undefined":
          return "undefined";
        case"boolean":
          return "boolean";
        case"number":
          return "number";
        case"string":
          return "string";
        case"symbol":
          return "symbol";
        default:
          return null === e ? "null" : "Symbol" in this && e instanceof this.Symbol ? "symbol" : "object"
      }
    }

    function CreateIterResultObject(e, r) {
      if ("boolean" !== Type(r)) throw new Error;
      var t = {};
      return CreateDataProperty(t, "value", e), CreateDataProperty(t, "done", r), t
    }

    function EnumerableOwnProperties(e, r) {
      for (var t = Object.keys(e), n = [], s = t.length, a = 0; a < s; a++) {
        var i = t[a];
        if ("string" === Type(i)) {
          var u = Object.getOwnPropertyDescriptor(e, i);
          if (u && u.enumerable) if ("key" === r) n.push(i); else {
            var p = Get(e, i);
            if ("value" === r) n.push(p); else {
              var f = [i, p];
              n.push(f)
            }
          }
        }
      }
      return n
    }

    function GetPrototypeFromConstructor(t, o) {
      var r = Get(t, "prototype");
      return "object" !== Type(r) && (r = o), r
    }

    function OrdinaryCreateFromConstructor(r, e) {
      var t = arguments[2] || {}, o = GetPrototypeFromConstructor(r, e), a = Object.create(o);
      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && Object.defineProperty(a, n, {
        configurable: !0,
        enumerable: !1,
        writable: !0,
        value: t[n]
      });
      return a
    }

    function IsConstructor(t) {
      return "object" === Type(t) && ("function" == typeof t && !!t.prototype)
    }

    function Construct(r) {
      var t = arguments.length > 2 ? arguments[2] : r, o = arguments.length > 1 ? arguments[1] : [];
      if (!IsConstructor(r)) throw new TypeError("F must be a constructor.");
      if (!IsConstructor(t)) throw new TypeError("newTarget must be a constructor.");
      if (t === r) return new (Function.prototype.bind.apply(r, [null].concat(o)));
      var n = OrdinaryCreateFromConstructor(t, Object.prototype);
      return Call(r, n, o)
    }

    function ArraySpeciesCreate(r, e) {
      if (1 / e == -Infinity && (e = 0), !1 === IsArray(r)) return ArrayCreate(e);
      var t = Get(r, "constructor");
      if ("object" === Type(t) && null === (t = "Symbol" in this && "species" in this.Symbol ? Get(t, this.Symbol.species) : undefined) && (t = undefined), t === undefined) return ArrayCreate(e);
      if (!IsConstructor(t)) throw new TypeError("C must be a constructor");
      return Construct(t, [e])
    }

    function IteratorClose(r, t) {
      if ("object" !== Type(r["[[Iterator]]"])) throw new Error(Object.prototype.toString.call(r["[[Iterator]]"]) + "is not an Object.");
      var e = r["[[Iterator]]"], o = GetMethod(e, "return");
      if (o === undefined) return t;
      try {
        var n = Call(o, e)
      } catch (c) {
        var a = c
      }
      if (t) return t;
      if (a) throw a;
      if ("object" !== Type(n)) throw new TypeError("Iterator's return method returned a non-object.");
      return t
    }

    function IteratorComplete(t) {
      if ("object" !== Type(t)) throw new Error(Object.prototype.toString.call(t) + "is not an Object.");
      return ToBoolean(Get(t, "done"))
    }

    function IteratorNext(t) {
      if (arguments.length < 2) var e = Call(t["[[NextMethod]]"], t["[[Iterator]]"]); else e = Call(t["[[NextMethod]]"], t["[[Iterator]]"], [arguments[1]]);
      if ("object" !== Type(e)) throw new TypeError("bad iterator");
      return e
    }

    function IteratorStep(t) {
      var r = IteratorNext(t);
      return !0 !== IteratorComplete(r) && r
    }

    function IteratorValue(t) {
      if ("object" !== Type(t)) throw new Error(Object.prototype.toString.call(t) + "is not an Object.");
      return Get(t, "value")
    }

    function OrdinaryToPrimitive(r, t) {
      if ("string" === t) var e = ["toString", "valueOf"]; else e = ["valueOf", "toString"];
      for (var i = 0; i < e.length; ++i) {
        var n = e[i], a = Get(r, n);
        if (IsCallable(a)) {
          var o = Call(a, r);
          if ("object" !== Type(o)) return o
        }
      }
      throw new TypeError("Cannot convert to primitive.")
    }

    function SameValueZero(n, e) {
      return Type(n) === Type(e) && ("number" === Type(n) ? !(!isNaN(n) || !isNaN(e)) || (1 / n === Infinity && 1 / e == -Infinity || (1 / n == -Infinity && 1 / e === Infinity || n === e)) : SameValueNonNumber(n, e))
    }

    function ToPrimitive(e) {
      var t = arguments.length > 1 ? arguments[1] : undefined;
      if ("object" === Type(e)) {
        if (arguments.length < 2) var i = "default"; else t === String ? i = "string" : t === Number && (i = "number");
        var r = "function" == typeof this.Symbol && "symbol" == typeof this.Symbol.toPrimitive ? GetMethod(e, this.Symbol.toPrimitive) : undefined;
        if (r !== undefined) {
          var n = Call(r, e, [i]);
          if ("object" !== Type(n)) return n;
          throw new TypeError("Cannot convert exotic object to primitive.")
        }
        return "default" === i && (i = "number"), OrdinaryToPrimitive(e, i)
      }
      return e
    }

    function ToString(t) {
      switch (Type(t)) {
        case"symbol":
          throw new TypeError("Cannot convert a Symbol value to a string");
        case"object":
          return ToString(ToPrimitive(t, "string"));
        default:
          return String(t)
      }
    }

    !function () {
      var e = {}.toString, t = "".split;
      CreateMethodProperty(Object, "entries", function r(n) {
        var c = ToObject(n), c = "[object String]" == e.call(n) ? t.call(n, "") : Object(n);
        return EnumerableOwnProperties(c, "key+value")
      })
    }();
    !function (t, r, n) {
      "use strict";
      var e, o = 0, u = "" + Math.random(), l = "__symbol:", c = l.length, a = "__symbol@@" + u, i = "defineProperty",
        f = "defineProperties", s = "getOwnPropertyNames", v = "getOwnPropertyDescriptor", b = "propertyIsEnumerable",
        h = t.prototype, y = h.hasOwnProperty, m = h[b], p = h.toString, g = Array.prototype.concat,
        w = t.getOwnPropertyNames ? t.getOwnPropertyNames(window) : [], d = t[s], S = function L(t) {
          if ("[object Window]" === p.call(t)) try {
            return d(t)
          } catch (r) {
            return g.call([], w)
          }
          return d(t)
        }, P = t[v], j = t.create, O = t.keys, E = t.freeze || t, N = t[i], _ = t[f], k = P(t, s),
        T = function (t, r, n) {
          if (!y.call(t, a)) try {
            N(t, a, {enumerable: !1, configurable: !1, writable: !1, value: {}})
          } catch (e) {
            t[a] = {}
          }
          t[a]["@@" + r] = n
        }, z = function (t, r) {
          var n = j(t);
          return S(r).forEach(function (t) {
            M.call(r, t) && G(n, t, r[t])
          }), n
        }, A = function (t) {
          var r = j(t);
          return r.enumerable = !1, r
        }, D = function Q() {
        }, F = function (t) {
          return t != a && !y.call(x, t)
        }, I = function (t) {
          return t != a && y.call(x, t)
        }, M = function R(t) {
          var r = "" + t;
          return I(r) ? y.call(this, r) && this[a]["@@" + r] : m.call(this, t)
        }, W = function (r) {
          var n = {
            enumerable: !1, configurable: !0, get: D, set: function (t) {
              e(this, r, {enumerable: !1, configurable: !0, writable: !0, value: t}), T(this, r, !0)
            }
          };
          try {
            N(h, r, n)
          } catch (o) {
            h[r] = n.value
          }
          return E(x[r] = N(t(r), "constructor", B))
        }, q = function U() {
          var t = arguments[0];
          if (this instanceof U) throw new TypeError("Symbol is not a constructor");
          return W(l.concat(t || "", u, ++o))
        }, x = j(null), B = {value: q}, C = function (t) {
          return x[t]
        }, G = function V(t, r, n) {
          var o = "" + r;
          return I(o) ? (e(t, o, n.enumerable ? A(n) : n), T(t, o, !!n.enumerable)) : N(t, r, n), t
        }, H = function (t) {
          return function (r) {
            return y.call(t, a) && y.call(t[a], "@@" + r)
          }
        }, J = function X(t) {
          return S(t).filter(t === h ? H(t) : I).map(C)
        };
      k.value = G, N(t, i, k), k.value = J, N(t, "getOwnPropertySymbols", k), k.value = function Y(t) {
        return S(t).filter(F)
      }, N(t, s, k), k.value = function Z(t, r) {
        var n = J(r);
        return n.length ? O(r).concat(n).forEach(function (n) {
          M.call(r, n) && G(t, n, r[n])
        }) : _(t, r), t
      }, N(t, f, k), k.value = M, N(h, b, k), k.value = q, N(n, "Symbol", k), k.value = function (t) {
        var r = l.concat(l, t, u);
        return r in h ? x[r] : W(r)
      }, N(q, "for", k), k.value = function (t) {
        if (F(t)) throw new TypeError(t + " is not a symbol");
        return y.call(x, t) ? t.slice(2 * c, -u.length) : void 0
      }, N(q, "keyFor", k), k.value = function $(t, r) {
        var n = P(t, r);
        return n && I(r) && (n.enumerable = M.call(t, r)), n
      }, N(t, v, k), k.value = function (t, r) {
        return 1 === arguments.length || void 0 === r ? j(t) : z(t, r)
      }, N(t, "create", k);
      var K = null === function () {
        return this
      }.call(null);
      k.value = K ? function () {
        var t = p.call(this);
        return "[object String]" === t && I(this) ? "[object Symbol]" : t
      } : function () {
        if (this === window) return "[object Null]";
        var t = p.call(this);
        return "[object String]" === t && I(this) ? "[object Symbol]" : t
      }, N(h, "toString", k), e = function (t, r, n) {
        var e = P(h, r);
        delete h[r], N(t, r, n), t !== h && N(h, r, e)
      }
    }(Object, 0, this);
    Object.defineProperty(Symbol, "iterator", {value: Symbol("iterator")});

    function GetIterator(t) {
      var e = arguments.length > 1 ? arguments[1] : GetMethod(t, Symbol.iterator), r = Call(e, t);
      if ("object" !== Type(r)) throw new TypeError("bad iterator");
      var o = GetV(r, "next"), a = Object.create(null);
      return a["[[Iterator]]"] = r, a["[[NextMethod]]"] = o, a["[[Done]]"] = !1, a
    }

    Object.defineProperty(Symbol, "species", {value: Symbol("species")});
    !function (e) {
      function t(e, t) {
        if ("object" !== Type(e)) throw new TypeError("createMapIterator called on incompatible receiver " + Object.prototype.toString.call(e));
        if (!0 !== e._es6Map) throw new TypeError("createMapIterator called on incompatible receiver " + Object.prototype.toString.call(e));
        var r = Object.create(n);
        return Object.defineProperty(r, "[[Map]]", {
          configurable: !0,
          enumerable: !1,
          writable: !0,
          value: e
        }), Object.defineProperty(r, "[[MapNextIndex]]", {
          configurable: !0,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(r, "[[MapIterationKind]]", {
          configurable: !0,
          enumerable: !1,
          writable: !0,
          value: t
        }), r
      }

      var r = function () {
        try {
          var e = {};
          return Object.defineProperty(e, "t", {
            configurable: !0, enumerable: !1, get: function () {
              return !0
            }, set: undefined
          }), !!e.t
        } catch (t) {
          return !1
        }
      }(), o = Symbol("undef"), a = function p() {
        if (!(this instanceof p)) throw new TypeError('Constructor Map requires "new"');
        var e = OrdinaryCreateFromConstructor(this, p.prototype, {_keys: [], _values: [], _size: 0, _es6Map: !0});
        r || Object.defineProperty(e, "size", {configurable: !0, enumerable: !1, writable: !0, value: 0});
        var t = arguments.length > 0 ? arguments[0] : undefined;
        if (null === t || t === undefined) return e;
        var o = e.set;
        if (!IsCallable(o)) throw new TypeError("Map.prototype.set is not a function");
        try {
          for (var a = GetIterator(t); ;) {
            var n = IteratorStep(a);
            if (!1 === n) return e;
            var i = IteratorValue(n);
            if ("object" !== Type(i)) try {
              throw new TypeError("Iterator value " + i + " is not an entry object")
            } catch (u) {
              return IteratorClose(a, u)
            }
            try {
              var l = i[0], c = i[1];
              o.call(e, l, c)
            } catch (f) {
              return IteratorClose(a, f)
            }
          }
        } catch (f) {
          if (Array.isArray(t) || "[object Arguments]" === Object.prototype.toString.call(t) || t.callee) {
            var y, s = t.length;
            for (y = 0; y < s; y++) o.call(e, t[y][0], t[y][1])
          }
        }
        return e
      };
      Object.defineProperty(a, "prototype", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: {}
      }), r ? Object.defineProperty(a, Symbol.species, {
        configurable: !0, enumerable: !1, get: function () {
          return this
        }, set: undefined
      }) : CreateMethodProperty(a, Symbol.species, a), CreateMethodProperty(a.prototype, "clear", function l() {
        var e = this;
        if ("object" !== Type(e)) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(e));
        if (!0 !== e._es6Map) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(e));
        for (var t = e._keys, a = 0; a < t.length; a++) e._keys[a] = o, e._values[a] = o;
        return this._size = 0, r || (this.size = this._size), undefined
      }), CreateMethodProperty(a.prototype, "constructor", a), CreateMethodProperty(a.prototype, "delete", function (e) {
        var t = this;
        if ("object" !== Type(t)) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(t));
        for (var a = t._keys, n = 0; n < a.length; n++) if (t._keys[n] !== o && SameValueZero(t._keys[n], e)) return this._keys[n] = o, this._values[n] = o, this._size = --this._size, r || (this.size = this._size), !0;
        return !1
      }), CreateMethodProperty(a.prototype, "entries", function c() {
        return t(this, "key+value")
      }), CreateMethodProperty(a.prototype, "forEach", function (e) {
        var t = this;
        if ("object" !== Type(t)) throw new TypeError("Method Map.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!IsCallable(e)) throw new TypeError(Object.prototype.toString.call(e) + " is not a function.");
        if (arguments[1]) var r = arguments[1];
        for (var a = t._keys, n = 0; n < a.length; n++) t._keys[n] !== o && t._values[n] !== o && e.call(r, t._values[n], t._keys[n], t);
        return undefined
      }), CreateMethodProperty(a.prototype, "get", function y(e) {
        var t = this;
        if ("object" !== Type(t)) throw new TypeError("Method Map.prototype.get called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.get called on incompatible receiver " + Object.prototype.toString.call(t));
        for (var r = t._keys, a = 0; a < r.length; a++) if (t._keys[a] !== o && SameValueZero(t._keys[a], e)) return t._values[a];
        return undefined
      }), CreateMethodProperty(a.prototype, "has", function s(e) {
        var t = this;
        if ("object" != typeof t) throw new TypeError("Method Map.prototype.has called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Map) throw new TypeError("Method Map.prototype.has called on incompatible receiver " + Object.prototype.toString.call(t));
        for (var r = t._keys, a = 0; a < r.length; a++) if (t._keys[a] !== o && SameValueZero(t._keys[a], e)) return !0;
        return !1
      }), CreateMethodProperty(a.prototype, "keys", function u() {
        return t(this, "key")
      }), CreateMethodProperty(a.prototype, "set", function f(e, t) {
        var a = this;
        if ("object" !== Type(a)) throw new TypeError("Method Map.prototype.set called on incompatible receiver " + Object.prototype.toString.call(a));
        if (!0 !== a._es6Map) throw new TypeError("Method Map.prototype.set called on incompatible receiver " + Object.prototype.toString.call(a));
        for (var n = a._keys, i = 0; i < n.length; i++) if (a._keys[i] !== o && SameValueZero(a._keys[i], e)) return a._values[i] = t, a;
        -0 === e && (e = 0);
        var p = {};
        return p["[[Key]]"] = e, p["[[Value]]"] = t, a._keys.push(p["[[Key]]"]), a._values.push(p["[[Value]]"]), ++a._size, r || (a.size = a._size), a
      }), r && Object.defineProperty(a.prototype, "size", {
        configurable: !0, enumerable: !1, get: function () {
          var e = this;
          if ("object" !== Type(e)) throw new TypeError("Method Map.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e));
          if (!0 !== e._es6Map) throw new TypeError("Method Map.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e));
          for (var t = e._keys, r = 0, a = 0; a < t.length; a++) e._keys[a] !== o && (r += 1);
          return r
        }, set: undefined
      }), CreateMethodProperty(a.prototype, "values", function h() {
        return t(this, "value")
      }), CreateMethodProperty(a.prototype, Symbol.iterator, a.prototype.entries), "name" in a || Object.defineProperty(a, "name", {
        configurable: !0,
        enumerable: !1,
        writable: !1,
        value: "Map"
      });
      var n = {};
      Object.defineProperty(n, "isMapIterator", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: !0
      }), CreateMethodProperty(n, "next", function b() {
        var e = this;
        if ("object" !== Type(e)) throw new TypeError("Method %MapIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(e));
        if (!e.isMapIterator) throw new TypeError("Method %MapIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(e));
        var t = e["[[Map]]"], r = e["[[MapNextIndex]]"], a = e["[[MapIterationKind]]"];
        if (t === undefined) return CreateIterResultObject(undefined, !0);
        if (!t._es6Map) throw new Error(Object.prototype.toString.call(t) + " has a [[MapData]] internal slot.");
        for (var n = t._keys, i = n.length; r < i;) {
          var p = Object.create(null);
          if (p["[[Key]]"] = t._keys[r], p["[[Value]]"] = t._values[r], r += 1, e["[[MapNextIndex]]"] = r, p["[[Key]]"] !== o) {
            if ("key" === a) var l = p["[[Key]]"]; else if ("value" === a) l = p["[[Value]]"]; else {
              if ("key+value" !== a) throw new Error;
              l = [p["[[Key]]"], p["[[Value]]"]]
            }
            return CreateIterResultObject(l, !1)
          }
        }
        return e["[[Map]]"] = undefined, CreateIterResultObject(undefined, !0)
      }), CreateMethodProperty(n, Symbol.iterator, function d() {
        return this
      });
      try {
        CreateMethodProperty(e, "Map", a)
      } catch (i) {
        e.Map = a
      }
    }(this);
    !function (e) {
      function t(e, t) {
        if ("object" != typeof e) throw new TypeError("createSetIterator called on incompatible receiver " + Object.prototype.toString.call(e));
        if (!0 !== e._es6Set) throw new TypeError("createSetIterator called on incompatible receiver " + Object.prototype.toString.call(e));
        var r = Object.create(i);
        return Object.defineProperty(r, "[[IteratedSet]]", {
          configurable: !0,
          enumerable: !1,
          writable: !0,
          value: e
        }), Object.defineProperty(r, "[[SetNextIndex]]", {
          configurable: !0,
          enumerable: !1,
          writable: !0,
          value: 0
        }), Object.defineProperty(r, "[[SetIterationKind]]", {
          configurable: !0,
          enumerable: !1,
          writable: !0,
          value: t
        }), r
      }

      var r = function () {
        try {
          var e = {};
          return Object.defineProperty(e, "t", {
            configurable: !0, enumerable: !1, get: function () {
              return !0
            }, set: undefined
          }), !!e.t
        } catch (t) {
          return !1
        }
      }(), o = Symbol("undef"), n = function c() {
        if (!(this instanceof c)) throw new TypeError('Constructor Set requires "new"');
        var e = OrdinaryCreateFromConstructor(this, c.prototype, {_values: [], _size: 0, _es6Set: !0});
        r || Object.defineProperty(e, "size", {configurable: !0, enumerable: !1, writable: !0, value: 0});
        var t = arguments.length > 0 ? arguments[0] : undefined;
        if (null === t || t === undefined) return e;
        var o = e.add;
        if (!IsCallable(o)) throw new TypeError("Set.prototype.add is not a function");
        try {
          for (var n = GetIterator(t); ;) {
            var a = IteratorStep(n);
            if (!1 === a) return e;
            var i = IteratorValue(a);
            try {
              o.call(e, i)
            } catch (y) {
              return IteratorClose(n, y)
            }
          }
        } catch (y) {
          if (!Array.isArray(t) && "[object Arguments]" !== Object.prototype.toString.call(t) && !t.callee) throw y;
          var l, p = t.length;
          for (l = 0; l < p; l++) o.call(e, t[l])
        }
        return e
      };
      Object.defineProperty(n, "prototype", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: {}
      }), r ? Object.defineProperty(n, Symbol.species, {
        configurable: !0, enumerable: !1, get: function () {
          return this
        }, set: undefined
      }) : CreateMethodProperty(n, Symbol.species, n), CreateMethodProperty(n.prototype, "add", function p(e) {
        var t = this;
        if ("object" != typeof t) throw new TypeError("Method Set.prototype.add called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.add called on incompatible receiver " + Object.prototype.toString.call(t));
        for (var n = t._values, a = 0; a < n.length; a++) {
          var i = n[a];
          if (i !== o && SameValueZero(i, e)) return t
        }
        return 1 / e == -Infinity && (e = 0), t._values.push(e), this._size = ++this._size, r || (this.size = this._size), t
      }), CreateMethodProperty(n.prototype, "clear", function y() {
        var e = this;
        if ("object" != typeof e) throw new TypeError("Method Set.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(e));
        if (!0 !== e._es6Set) throw new TypeError("Method Set.prototype.clear called on incompatible receiver " + Object.prototype.toString.call(e));
        for (var t = e._values, n = 0; n < t.length; n++) t[n] = o;
        return this._size = 0, r || (this.size = this._size), undefined
      }), CreateMethodProperty(n.prototype, "constructor", n), CreateMethodProperty(n.prototype, "delete", function (e) {
        var t = this;
        if ("object" != typeof t) throw new TypeError("Method Set.prototype.delete called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.delete called on incompatible receiver " + Object.prototype.toString.call(t));
        for (var n = t._values, a = 0; a < n.length; a++) {
          var i = n[a];
          if (i !== o && SameValueZero(i, e)) return n[a] = o, this._size = --this._size, r || (this.size = this._size), !0
        }
        return !1
      }), CreateMethodProperty(n.prototype, "entries", function u() {
        return t(this, "key+value")
      }), CreateMethodProperty(n.prototype, "forEach", function f(e) {
        var t = this;
        if ("object" != typeof t) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!IsCallable(e)) throw new TypeError(Object.prototype.toString.call(e) + " is not a function.");
        if (arguments[1]) var r = arguments[1];
        for (var n = t._values, a = 0; a < n.length; a++) {
          var i = n[a];
          i !== o && e.call(r, i, i, t)
        }
        return undefined
      }), CreateMethodProperty(n.prototype, "has", function d(e) {
        var t = this;
        if ("object" != typeof t) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t));
        if (!0 !== t._es6Set) throw new TypeError("Method Set.prototype.forEach called on incompatible receiver " + Object.prototype.toString.call(t));
        for (var r = t._values, n = 0; n < r.length; n++) {
          var a = r[n];
          if (a !== o && SameValueZero(a, e)) return !0
        }
        return !1
      });
      var a = function h() {
        return t(this, "value")
      };
      CreateMethodProperty(n.prototype, "values", a), CreateMethodProperty(n.prototype, "keys", a), r && Object.defineProperty(n.prototype, "size", {
        configurable: !0,
        enumerable: !1,
        get: function () {
          var e = this;
          if ("object" != typeof e) throw new TypeError("Method Set.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e));
          if (!0 !== e._es6Set) throw new TypeError("Method Set.prototype.size called on incompatible receiver " + Object.prototype.toString.call(e));
          for (var t = e._values, r = 0, n = 0; n < t.length; n++) {
            t[n] !== o && (r += 1)
          }
          return r
        },
        set: undefined
      }), CreateMethodProperty(n.prototype, Symbol.iterator, a), "name" in n || Object.defineProperty(n, "name", {
        configurable: !0,
        enumerable: !1,
        writable: !1,
        value: "Set"
      });
      var i = {};
      Object.defineProperty(i, "isSetIterator", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: !0
      }), CreateMethodProperty(i, "next", function b() {
        var e = this;
        if ("object" != typeof e) throw new TypeError("Method %SetIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(e));
        if (!e.isSetIterator) throw new TypeError("Method %SetIteratorPrototype%.next called on incompatible receiver " + Object.prototype.toString.call(e));
        var t = e["[[IteratedSet]]"], r = e["[[SetNextIndex]]"], n = e["[[SetIterationKind]]"];
        if (t === undefined) return CreateIterResultObject(undefined, !0);
        if (!t._es6Set) throw new Error(Object.prototype.toString.call(t) + " does not have [[SetData]] internal slot.");
        for (var a = t._values, i = a.length; r < i;) {
          var l = a[r];
          if (r += 1, e["[[SetNextIndex]]"] = r, l !== o) return "key+value" === n ? CreateIterResultObject([l, l], !1) : CreateIterResultObject(l, !1)
        }
        return e["[[IteratedSet]]"] = undefined, CreateIterResultObject(undefined, !0)
      }), CreateMethodProperty(i, Symbol.iterator, function s() {
        return this
      });
      try {
        CreateMethodProperty(e, "Set", n)
      } catch (l) {
        e.Set = n
      }
    }(this);
    !function () {
      function r(r) {
        return "string" == typeof r || "object" == typeof r && "[object String]" === t.call(r)
      }

      var t = Object.prototype.toString, e = String.prototype.match;
      CreateMethodProperty(Array, "from", function o(t) {
        var o = this, a = arguments.length > 1 ? arguments[1] : undefined;
        if (a === undefined) var n = !1; else {
          if (!1 === IsCallable(a)) throw new TypeError(Object.prototype.toString.call(a) + " is not a function.");
          var i = arguments.length > 2 ? arguments[2] : undefined;
          if (i !== undefined) var l = i; else l = undefined;
          n = !0
        }
        var u = GetMethod(t, Symbol.iterator);
        if (u !== undefined) {
          if (IsConstructor(o)) var f = Construct(o); else f = ArrayCreate(0);
          for (var c = GetIterator(t, u), s = 0; ;) {
            if (s >= Math.pow(2, 53) - 1) {
              var h = new TypeError("Iteration count can not be greater than or equal 9007199254740991.");
              return IteratorClose(c, h)
            }
            var y = ToString(s), C = IteratorStep(c);
            if (!1 === C) return f.length = s, f;
            var g = IteratorValue(C);
            if (n) try {
              var p = Call(a, l, [g, s])
            } catch (b) {
              return IteratorClose(c, b)
            } else p = g;
            try {
              CreateDataPropertyOrThrow(f, y, p)
            } catch (b) {
              return IteratorClose(c, b)
            }
            s += 1
          }
        }
        if (r(t)) var v = e.call(t, /[\uD800-\uDBFF][\uDC00-\uDFFF]?|[^\uD800-\uDFFF]|./g) || []; else v = ToObject(t);
        var d = ToLength(Get(v, "length"));
        for (f = IsConstructor(o) ? Construct(o, [d]) : ArrayCreate(d), s = 0; s < d;) {
          y = ToString(s);
          var I = Get(v, y);
          p = !0 === n ? Call(a, l, [I, s]) : I, CreateDataPropertyOrThrow(f, y, p), s += 1
        }
        return f.length = d, f
      })
    }();
  }).call('object' === typeof window && window || 'object' === typeof self && self || 'object' === typeof global && global || {});


  Symbol.toStringTag = "Symbol(Symbol.toStringTag)";
  // Object.prototype[Symbol.toStringTag] =  Object.prototype[Symbol.toStringTag] + '';


  var consoleOrigin
  if (typeof console === 'undefined') {
    window.console = {}
  }

  consoleOrigin = {
    log: console.log || function() {},
    error: console.error || function() {},
    info: console.info || function() {},
    warn: console.warn || function() {},
    group: console.group || function() {},
    groupEnd: console.groupEnd || function() {},
    trace: console.trace || function() {}
  }

  window.console.log = function() {
    try {
      consoleOrigin.log.apply(null, arguments)
    } catch (e) {}
  }

  window.console.error = function() {
    try {
      consoleOrigin.error.apply(null, arguments)
    } catch (e) {}
  }

  window.console.info = function() {
    try {
      consoleOrigin.info.apply(null, arguments)
    } catch (e) {}
  }

  window.console.warn = function() {
    try {
      consoleOrigin.warn.apply(null, arguments)
    } catch (e) {}
  }

  window.console.group = function() {
    try {
      consoleOrigin.group.apply(null, arguments)
    } catch (e) {}
  }

  window.console.groupEnd = function() {
    try {
      consoleOrigin.groupEnd.apply(null, arguments)
    } catch (e) {}
  }
}
